//! Protocol types for agent-rdp IPC communication.
//!
//! This crate defines the request and response types used for
//! communication between the CLI and the daemon over IPC.

mod automation;
mod request;
mod response;

pub use automation::*;
pub use request::*;
pub use response::*;

#[cfg(test)]
mod codegen {
    use super::*;
    use std::fs;
    use std::path::Path;

    /// Generate TypeScript types from Rust types.
    /// ts-rs automatically generates files when types are exported.
    #[test]
    fn generate_typescript_types() {
        use ts_rs::TS;

        // Create output directory
        let out_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../packages/agent-rdp/src/generated");
        fs::create_dir_all(&out_dir).unwrap();

        // Export all types - ts-rs generates files via #[ts(export)]
        // We need to call export_all() to trigger generation
        Request::export_all().unwrap();
        Response::export_all().unwrap();
        AutomateRequest::export_all().unwrap();
        // Export IPC types that aren't directly referenced by the main types
        AutomationHandshake::export_all().unwrap();
        FileIpcRequest::export_all().unwrap();
        FileIpcResponse::export_all().unwrap();

        // Fix imports in generated files: add .js extension for ESM compatibility
        let entries: Vec<_> = fs::read_dir(&out_dir)
            .unwrap()
            .filter_map(|e| e.ok())
            .filter(|e| {
                let name = e.file_name().to_string_lossy().to_string();
                name.ends_with(".ts") && name != "index.ts"
            })
            .collect();

        for entry in &entries {
            let path = entry.path();
            let content = fs::read_to_string(&path).unwrap();
            // Fix imports: from "./Foo" to from "./Foo.js"
            let fixed = content
                .lines()
                .map(|line| {
                    if line.starts_with("import ") && line.contains("from \"./") && !line.contains(".js\"") {
                        line.replace("\";", ".js\";")
                    } else {
                        line.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("\n");
            fs::write(&path, fixed + "\n").unwrap();
        }

        // Generate index.ts that re-exports all types (sorted for deterministic output)
        let mut type_names: Vec<String> = entries
            .iter()
            .map(|e| e.file_name().to_string_lossy().trim_end_matches(".ts").to_string())
            .collect();
        type_names.sort();

        let mut index_content = String::from("// Auto-generated by cargo test - do not edit manually\n\n");
        for type_name in &type_names {
            index_content.push_str(&format!("export type {{ {} }} from './{}.js';\n", type_name, type_name));
        }

        fs::write(out_dir.join("index.ts"), index_content).unwrap();

        println!("TypeScript types generated to: {}", out_dir.display());
    }

    /// Generate JSON fixtures for PowerShell integration tests.
    /// These fixtures can be used to verify PowerShell scripts handle all request types correctly.
    #[test]
    fn generate_ps_fixtures() {
        let fixtures_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../fixtures/automation");
        fs::create_dir_all(&fixtures_dir).unwrap();

        // Generate fixture for each automation request type
        let fixtures: Vec<(&str, AutomateRequest)> = vec![
            (
                "snapshot",
                AutomateRequest::Snapshot {
                    interactive_only: true,
                    compact: false,
                    max_depth: 10,
                    selector: None,
                    focused: false,
                },
            ),
            (
                "snapshot_focused",
                AutomateRequest::Snapshot {
                    interactive_only: false,
                    compact: true,
                    max_depth: 5,
                    selector: Some("#Window".to_string()),
                    focused: true,
                },
            ),
            (
                "get",
                AutomateRequest::Get {
                    selector: "@5".to_string(),
                    property: Some("value".to_string()),
                },
            ),
            (
                "focus",
                AutomateRequest::Focus {
                    selector: "@5".to_string(),
                },
            ),
            (
                "click",
                AutomateRequest::Click {
                    selector: "@5".to_string(),
                    double_click: false,
                },
            ),
            (
                "click_double",
                AutomateRequest::Click {
                    selector: "#Button[name='OK']".to_string(),
                    double_click: true,
                },
            ),
            (
                "select",
                AutomateRequest::Select {
                    selector: "@10".to_string(),
                    item: Some("Option 1".to_string()),
                },
            ),
            (
                "toggle",
                AutomateRequest::Toggle {
                    selector: "@3".to_string(),
                    state: Some(true),
                },
            ),
            (
                "expand",
                AutomateRequest::Expand {
                    selector: "@7".to_string(),
                },
            ),
            (
                "collapse",
                AutomateRequest::Collapse {
                    selector: "@7".to_string(),
                },
            ),
            (
                "context_menu",
                AutomateRequest::ContextMenu {
                    selector: "@5".to_string(),
                },
            ),
            (
                "fill",
                AutomateRequest::Fill {
                    selector: "#TextBox[name='Username']".to_string(),
                    text: "testuser".to_string(),
                },
            ),
            (
                "clear",
                AutomateRequest::Clear {
                    selector: "@5".to_string(),
                },
            ),
            (
                "scroll",
                AutomateRequest::Scroll {
                    selector: "@5".to_string(),
                    direction: Some(AutomationScrollDirection::Down),
                    amount: Some(3),
                    to_child: None,
                },
            ),
            (
                "scroll_to_child",
                AutomateRequest::Scroll {
                    selector: "@5".to_string(),
                    direction: None,
                    amount: None,
                    to_child: Some("@15".to_string()),
                },
            ),
            (
                "window_list",
                AutomateRequest::Window {
                    action: WindowAction::List,
                    selector: None,
                },
            ),
            (
                "window_maximize",
                AutomateRequest::Window {
                    action: WindowAction::Maximize,
                    selector: Some("#Notepad".to_string()),
                },
            ),
            (
                "run",
                AutomateRequest::Run {
                    command: "notepad.exe".to_string(),
                    args: vec!["test.txt".to_string()],
                    wait: false,
                    hidden: false,
                    timeout_ms: 10000,
                },
            ),
            (
                "run_wait",
                AutomateRequest::Run {
                    command: "cmd".to_string(),
                    args: vec!["/c".to_string(), "echo hello".to_string()],
                    wait: true,
                    hidden: true,
                    timeout_ms: 5000,
                },
            ),
            (
                "wait_for",
                AutomateRequest::WaitFor {
                    selector: "@5".to_string(),
                    timeout_ms: 30000,
                    state: WaitState::Visible,
                },
            ),
            ("status", AutomateRequest::Status),
        ];

        for (name, request) in fixtures {
            // Create the FileIpcRequest wrapper format that PowerShell agent expects
            let file_ipc_request = FileIpcRequest {
                id: format!("test-{}", name),
                command: get_command_name(&request),
                params: serde_json::to_value(&request).unwrap(),
            };

            let json = serde_json::to_string_pretty(&file_ipc_request).unwrap();
            let path = fixtures_dir.join(format!("{}.json", name));
            fs::write(&path, json).unwrap();
        }

        // Generate response fixtures
        let response_fixtures_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../fixtures/responses");
        fs::create_dir_all(&response_fixtures_dir).unwrap();

        let response_fixtures: Vec<(&str, FileIpcResponse)> = vec![
            (
                "success_snapshot",
                FileIpcResponse {
                    id: "test-snapshot".to_string(),
                    timestamp: "2024-01-01T00:00:00Z".to_string(),
                    success: true,
                    data: Some(serde_json::json!({
                        "snapshot_id": "snap-001",
                        "ref_count": 15,
                        "truncated": false,
                        "max_depth": 10,
                        "root": {
                            "ref": 1,
                            "role": "window",
                            "name": "Test Window",
                            "children": []
                        }
                    })),
                    error: None,
                },
            ),
            (
                "success_click",
                FileIpcResponse {
                    id: "test-click".to_string(),
                    timestamp: "2024-01-01T00:00:00Z".to_string(),
                    success: true,
                    data: Some(serde_json::json!({
                        "clicked": true,
                        "method": "invoke",
                        "x": 100,
                        "y": 200
                    })),
                    error: None,
                },
            ),
            (
                "error_element_not_found",
                FileIpcResponse {
                    id: "test-click".to_string(),
                    timestamp: "2024-01-01T00:00:00Z".to_string(),
                    success: false,
                    data: None,
                    error: Some(FileIpcError {
                        code: "element_not_found".to_string(),
                        message: "Element with selector @99 not found".to_string(),
                    }),
                },
            ),
        ];

        for (name, response) in response_fixtures {
            let json = serde_json::to_string_pretty(&response).unwrap();
            let path = response_fixtures_dir.join(format!("{}.json", name));
            fs::write(&path, json).unwrap();
        }

        println!("PowerShell fixtures generated to: {}", fixtures_dir.display());
    }

    fn get_command_name(request: &AutomateRequest) -> String {
        match request {
            AutomateRequest::Snapshot { .. } => "snapshot",
            AutomateRequest::Get { .. } => "get",
            AutomateRequest::Focus { .. } => "focus",
            AutomateRequest::Click { .. } => "click",
            AutomateRequest::Select { .. } => "select",
            AutomateRequest::Toggle { .. } => "toggle",
            AutomateRequest::Expand { .. } => "expand",
            AutomateRequest::Collapse { .. } => "collapse",
            AutomateRequest::ContextMenu { .. } => "context_menu",
            AutomateRequest::Fill { .. } => "fill",
            AutomateRequest::Clear { .. } => "clear",
            AutomateRequest::Scroll { .. } => "scroll",
            AutomateRequest::Window { .. } => "window",
            AutomateRequest::Run { .. } => "run",
            AutomateRequest::WaitFor { .. } => "wait_for",
            AutomateRequest::Status => "status",
        }
        .to_string()
    }
}
